namespace Bugs
{
    constraint NumUnary(x:Num):Num

    wrappedLambdasOneLine:NumUnary
    {
        wrap(unary:NumUnary):NumUnary
        {
            return(x:Num):Num = unary(x)
        }

        foo = _(u:Num):Num = u
        fooWrapped = wrap(foo)
        fooWrappedTwice = wrap(fooWrapped)
        return = fooWrappedTwice
    }

    wrappedLambdasExplicit:NumUnary
    {
        wrap(unary:NumUnary):NumUnary
        {
            return = _(x:Num):Num
            {
                return = unary(x)
            }
        }

        foo = _(u:Num):Num = u
        fooWrapped = wrap(foo)
        fooWrappedTwice = wrap(fooWrapped)
        return = fooWrappedTwice
    }

    wrappedLambdasNamed:NumUnary
    {
        wrap(unary:NumUnary):NumUnary
        {
            namedFunction(x:Num):Num
            {
                return = unary(x)
            }
            return = namedFunction
        }

        foo = _(u:Num):Num = u
        fooWrapped = wrap(foo)
        fooWrappedTwice = wrap(fooWrapped)
        return = fooWrappedTwice
    }

    adderRecursionLambdas(x:Num):Num
    {
        getAdder(n:Num):NumUnary
        {
            return = _(x:Num):Num
            {
                return = x.add(n)
            }
        }

        oneAdder = getAdder(1)
        twoAdder = getAdder(2)
        threeAdder = getAdder(3)
        fourAdder = getAdder(4)

        combineAdders(a1:NumUnary, a2:NumUnary):NumUnary
        {
            return = _(x:Num):Num
            {
                return = a2(a1(x))
            }
        }

        myThreeAdder = combineAdders(oneAdder, twoAdder)
        mySevenAdder = combineAdders(threeAdder, fourAdder)

        myTenAdder = combineAdders(myThreeAdder, mySevenAdder)
        
        # This evaluates to:
        # myTenAdder = combineAdders(combineAdders(oneAdder, twoAdder), combineAdders(myThreeAdder, mySevenAdder))
        # which is recognised as recursion

        return = myTenAdder(x)
    }


    adderRecursionReturnFunction(x:Num):Num
    {
        getAdder(n:Num):NumUnary
        {
            return(x:Num):Num = x.add(n)
        }

        oneAdder = getAdder(1)
        twoAdder = getAdder(2)
        threeAdder = getAdder(3)
        fourAdder = getAdder(4)

        combineAdders(a1:NumUnary, a2:NumUnary):NumUnary
        {
            return(x:Num):Num = a2(a1(x))
        }

        myThreeAdder = combineAdders(oneAdder, twoAdder)
        mySevenAdder = combineAdders(threeAdder, fourAdder)

        myTenAdder = combineAdders(myThreeAdder, mySevenAdder)
        
        # This evaluates to:
        # myTenAdder = combineAdders(combineAdders(oneAdder, twoAdder), combineAdders(myThreeAdder, mySevenAdder))
        # which is recognised as recursion

        return = myTenAdder(x)
    }

    

    constraintError(x:Num):Num
    {
        evaluate(f:NumUnary, n:Num):Num = f(n)

        struct Adder(u:Num)
        {
            add(this:Adder, x:Num):Num = this.u.add(x)
        }
        zeroAdder = Adder(0)
        return = evaluate(zeroAdder.add, x)
    }
}
