struct TimePoint(integer:Num, fractional:Num)
{
    fromSeconds(x:Num):TimePoint = TimePoint(x.floor, x.sub(x.floor))

    value(this:TimePoint, period:Num):Num = this.integer.rem(period).add(this.fractional).rem(period)
    cycles(this:TimePoint, period:Num):Num = this.integer.div(period).add(this.fractional.div(period).floor)

    mul(this:TimePoint, x:Num):TimePoint
    {
        struct MultiplicableTimeSpan(encodedInteger:Num, encodedFractional:Num, isPositive:Bool)
        {
            fromTimeSpan(ts:TimePoint):MultiplicableTimeSpan
            {
                return = if(
                    ts.integer.geq(0),
                    MultiplicableTimeSpan(ts.integer, ts.fractional, true).regularise,
                    MultiplicableTimeSpan(ts.integer.abs.sub(1), 1.sub(ts.fractional), false).regularise
                )
            }

            toTimeSpan(mts:MultiplicableTimeSpan):TimePoint
            {
                return = if(
                    mts.isPositive,
                    TimePoint(mts.encodedInteger, mts.encodedFractional),
                    TimePoint(mts.encodedInteger.mul(-1).sub(1), 1.sub(mts.encodedFractional))
                )
            }

            multiply(this:MultiplicableTimeSpan, x:Num)
            {
                resultIsPositive = this.isPositive.xnor(x.geq(0))
                multipliedInteger = this.encodedInteger.mul(x.abs)
                multipliedFractional = this.encodedFractional.mul(x.abs)

                # The multipliedInteger may have acquired a fractional component, so move this
                # onto the newFractional component.
                newInteger = multipliedInteger.floor
                newFractional = multipliedFractional.add(multipliedInteger.rem(1))

                return = MultiplicableTimeSpan(newInteger, newFractional, resultIsPositive).regularise
            }

            regularise(this:MultiplicableTimeSpan)
            {
                return = MultiplicableTimeSpan(this.encodedInteger.add(this.encodedFractional.floor), this.encodedFractional.rem(1), this.isPositive)
            }
        }

        multiplicableTimeSpan = MultiplicableTimeSpan.fromTimeSpan(this)
        return = multiplicableTimeSpan.multiply(x).toTimeSpan.regularise
    }

    div(this:TimePoint, x:Num):TimePoint
    {
        return = this.mul(1.div(x))
    }

    add(this:TimePoint, other:TimePoint):TimePoint
    {
        return = TimePoint(this.integer.add(other.integer), this.fractional.add(other.fractional)).regularise
    }

    sub(this:TimePoint, other:TimePoint):TimePoint
    {
        return = this.add(other.negate)
    }

    regularise(this:TimePoint):TimePoint
    {
        return = TimePoint(this.integer.add(this.fractional.floor), this.fractional.rem(1))
    }

    negate(this:TimePoint):TimePoint
    {
        return = TimePoint(this.integer.mul(-1).sub(1), 1.sub(this.fractional)).regularise
    }

    abs(this:TimePoint):TimePoint
    {
        return = if(this.integer.geq(0), this, this.mul(-1))
    }
}
