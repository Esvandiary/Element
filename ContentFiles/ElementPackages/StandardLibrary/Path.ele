constraint PathFunc(u:Num):Vector3

namespace Path
{
    struct Bounds(lower:Num, upper:Num)

    constraint ScalarTransform(x:Num):Num
    constraint Vector3Unary(v:Vector3):Vector3
    constraint Vector3Binary(v1:Vector3, v2:Vector3):Vector3

    scaleInputBounds(path:PathFunc, old:Bounds, new:Bounds):PathFunc
    {
        # Scale the input bounds from "old" to "new".
        #
        # This function maps the function "path" to the function "newPath"
        # such that:
        #   newPath(new.lower) = path(old.lower)
        #   newPath(new.upper) = path(old.upper)

        uTransform(u:Num):Num
        {
            return = Num.lerp(u.sub(new.lower).div(new.upper.sub(new.lower)), old.lower, old.upper)
        }
        return = applyInputTransform(path, uTransform)
    }

    pingPong(path:PathFunc):PathFunc
    {
        # Maps the input of (0, 1) to the range 0 to 1 and to 0.
        #
        # This means that the path length is double the original path length.
        
        uTransform(u:Num):Num
        {
            w = u.mul(2)
            return = if(w.gt(1), 2.sub(w), w)
        }
        return = applyInputTransform(path, uTransform)
    }

    repeat(path:PathFunc, repetitions:Num):PathFunc
    {
        # Returns the same path repated ... still takes range (0, 1) but repeats
        # that range "repetitions" times in that same interval.
        #
        # This changes the path length
        
        uTransform(u:Num):Num = u.mul(repetitions).rem(1)
        return = applyInputTransform(path, uTransform)
    }

    reverse(path:PathFunc):PathFunc
    {
        uTransform(u:Num):Num = 1.sub(u)
        return = applyInputTransform(path, uTransform)
    }

    oscillate(path:PathFunc):PathFunc
    {
        uTransform(u:Num):Num = Num.sub(0.5, Num.cos(u.mul(Num.tau)).div(2))
        return = applyInputTransform(path, uTransform)
    }

    easing(path:PathFunc):PathFunc
    {
        # Map 0 to 1 to the same range, but more smoothly 
        smoothstep(t:Num):Num = 3.mul(t.mul(t)).sub(2.mul(t.mul(t).mul(t)))
        return = applyInputTransform(path, smoothstep)
    }

    concatenate(path1:PathFunc, path2:PathFunc, boundary:Num):PathFunc
    {
        # If "a" and "b" are both PathFuncs defined over the region (0, 1),
        # and "boundary" is a number between 0 and 1, then this maps (0, boundary) to "a"s (0, 1)
        # and (boundary, 1) to "b"s (0, 1)

        transformedPath1 = scaleInputBounds(path1, Bounds(0, 1), Bounds(0, boundary))
        transformedPath2 = scaleInputBounds(path2, Bounds(0, 1), Bounds(boundary, 1))

        return(u:Num):Vector3
        {
            return = if(u.leq(boundary), transformedPath1(u), transformedPath2(u))
        }
    }

    applyInputTransform(path:PathFunc, inputTransform:ScalarTransform):PathFunc
    {
        # Apply a transform to the input argument of a path
        return(u:Num):Vector3
        {
            return = path(inputTransform(u))
        }
    }

    applyTransform(path:PathFunc, transform:Transform):PathFunc
    {
        # Apply a Transform to all points on the path
        return = applyUnaryVectorOperation(path, transform.applyToPosition)
    }

    applyOffset(path:PathFunc, offset:Vector3):PathFunc
    {
        # Apply an offset to the path
        adder = _(v:Vector3):Vector3 = v.add(offset)
        return = applyUnaryVectorOperation(path, adder)
    }

    applyUnaryVectorOperation(path:PathFunc, operation:Vector3Unary):PathFunc
    {
        # Apply the operation to all points on the path
        return(u:Num):Vector3
        {
            return = operation(path(u))
        }
    }

    applyBinaryVectorOperation(path1:PathFunc, path2:PathFunc, operation:Vector3Binary):PathFunc
    {
        # Combine the two paths by applying the binary operation at each point
        return(u:Num):Vector3
        {
            path1Pos = path1(u)
            path2Pos = path2(u)
            return = operation(path1Pos, path2Pos)
        }
    }
}
