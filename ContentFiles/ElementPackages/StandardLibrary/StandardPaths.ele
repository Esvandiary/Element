namespace StandardPaths
{
    # Standard Paths are pre-defined parametric functions for paths
    # They are all written to accept numbers between 0 and 1
    #
    # If the path length is possible to calculate analytically, a
    # separate function is defined to provide it.

    # All StandardPaths expect inputs between 0 and 1, and this
    # is represented by this struct.
    bounds:Path.Bounds = Path.Bounds(0, 1)

    circle(radius:Num):PathFunc
    {
        # Return a clockwise circle in the x-y plane, beginning at
        # x=0, y=radius
        return = _(u:Num):Vector3
        {
            x = radius.mul(Num.sin(u.mul(Num.tau)))
            y = radius.mul(Num.cos(u.mul(Num.tau)))
            return = Vector3(x, y, 0)
        }
    }
    circleLength(radius:Num):Num = Num.tau.mul(radius)

    line(a:Vector3, b:Vector3):PathFunc = _(u:Num):Vector3 = Vector3.lerp(u, a, b)
    lineLength(a:Vector3, b:Vector3):Num = Vector3.distance(a, b)

    rectangle(width:Num, height:Num):PathFunc
    {
        # Create a rectangle in the x-y plane, starting at the origin
        #
        # Goes clockwise to the points: (0, 0, 0), (0, height, 0), (width, height, 0), (width, 0, 0)
        # in that order.

        pointA = Vector3(0, 0, 0)
        pointB = Vector3(0, height, 0)
        pointC = Vector3(width, height, 0)
        pointD = Vector3(width, 0, 0)

        lineAB = line(pointA, pointB)
        lineBC = line(pointB, pointC)
        lineCD = line(pointC, pointD)
        lineDA = line(pointD, pointA)

        concatAC = Path.concatenate(lineAB, lineBC, height.div(height.add(width)))
        concatCA = Path.concatenate(lineCD, lineDA, height.div(height.add(width)))
        return = Path.concatenate(concatAC, concatCA, 0.5)
    }
    rectangleLength(width:Num, height:Num):Num = 2.mul(width.add(height))

    lissajous(radii:Vector2, frequencies:Vector2, phaseDifference:Num):PathFunc
    {
        omega = frequencies.scale(Num.tau)  # Angular Frequencies

        return = _(u:Num):Vector3
        {
            xPhase = u.mul(omega.x)
            yPhase = u.mul(omega.y).add(phaseDifference)
            xProgress = Num.sin(xPhase)
            yProgress = Num.sin(yPhase)
            xPos = xProgress.mul(radii.x)
            yPos = yProgress.mul(radii.y)
            return = Vector3(xPos, yPos, 0)
        }
    }
}

#    lissajous(position: Vector3, size:Vector2, frequency:Vector2):Path
#     {
#        return = _(progress:Num):Vector3
#        {
#            angularFrequency = Vector2(Num.tau.mul(frequency.x),
#                                        Num.tau.mul(frequency.y))

#            point = Vector2(size.x.mul(Num.cos(angularFrequency.x.mul(progress))),
#                            size.y.mul(Num.sin(angularFrequency.y.mul(progress))))

#            return = position.add(Vector3(point.x, point.y, 0))
#        }
#     }


    #   rose(diameter:Num, n:Num, d:Num, frequency:Num):Path
    #   {
    #       k = Num.div(n, d)
    #       at(u:Num):Vector3
    #       {
    #           ut = Num.mul(u, tau)
    #           r = Num.mul(diameter, Num.cos(Num.mul(ut, k)))
    #
    #           return = Vector3(Num.mul(r, Num.cos(Num.mul(ut, frequency))), Num.mul(r, Num.sin(Num.mul(ut, frequency))), 0)
    #       }
    #       return = Path(at, Num.mul(Num.mul(diameter, 4), ellipse(k, 1)))
    #   }
