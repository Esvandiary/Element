#namespace Vector
#{
#    add(a, b) = memberwise(Num.add, a, b);
#    sub(a, b) = memberwise(Num.sub, a, b);
#    mul(a, b) = memberwise(Num.mul, a, b);
#    div(a, b) = memberwise(Num.div, a, b);
#
#    lerp(t:Num, a, b) = memberwise(_(ax, bx) = Num.lerp(t, ax, bx), a, b);
#
#    scale(v, scaleFactor:Num) = map(_(component) = component.mul(scaleFactor), v);
#}

struct Vector2(x:Num, y:Num)
{
#    Right = Vector2(1, 0);
#    Left = Vector2(-1, 0);
#    Up = Vector2(0, 1);    #Not sure what to do here, names contradict with Vector3 definitions of up/down 
#    Down = Vector2(0, -1); #Not sure what to do here, names contradict with Vector3 definitions of up/down

    #vector properties
    MagnitudeSquared(v:Vector2):Num = v.Dot(v);
    Magnitude(v:Vector2):Num = Num.sqrt(v.MagnitudeSquared);

    #operations
    Opposite(v:Vector2):Vector2 = Vector2(0.sub(v.x), 0.sub(v.y));
    
    Normalize(v:Vector2):Vector2
    {
       len = Magnitude(v);
       return = v.Div(len);
    }
    
    #scalar operations
    Mul(a:Vector2, b:Num):Vector2 = Vector2(a.x.mul(b), a.y.mul(b));
    Div(a:Vector2, b:Num):Vector2 = a.Mul(1.div(b));
    
    #vector operations
    Add(a:Vector2, b:Vector2):Vector2 = Vector2(a.x.add(b.x), a.y.add(b.y));
    Sub(a:Vector2, b:Vector2):Vector2 = a.Add(Opposite(b));
    
    Dot(a:Vector2, b:Vector2):Num
    {
        s = Vector2(a.x.mul(b.x), a.y.mul(b.y));
        return = s.x.add(s.y);
    }
        
    Distance(a:Vector2, b:Vector2):Num 
    {
       diff = a.Sub(b);
       return = diff.Magnitude;
    }

    Angle(a:Vector2, b:Vector2):Num 
    {
        dot = a.Dot(b);
        mag = a.Magnitude.mul(b.Magnitude);
        theta = Num.acos(dot.div(mag));
        return = Num.degrees(theta);  
    }
    
    Reflect(l:Vector2, n:Vector2):Vector2
    {
        dot = n.Dot(l);
        s = 2.mul(dot);
        t = n.Mul(s);
        return = t.Sub(l);
    }
}

struct Vector3(x:Num, y:Num, z:Num)
{
    Up = Vector3(0, 0, 1);
    Down = Vector3(0, 0, -1);
    Right = Vector3(1, 0, 0);
    Left = Vector3(-1, 0, 0);
    Forward = Vector3(0, 1, 0);
    Back = Vector3(0, -1, 0);

    #vector properties
    MagnitudeSquared(v:Vector3):Num = v.Dot(v);
    Magnitude(v:Vector3):Num = Num.sqrt(v.MagnitudeSquared);

    #operations
    Opposite(v:Vector3):Vector3 = Vector3(0.sub(v.x), 0.sub(v.y), 0.sub(v.z));
    
    Normalize(v:Vector3):Vector3
    {
       len = Magnitude(v);
       return = v.Div(len);
    }
    
    #scalar operations
    Mul(a:Vector3, b:Num):Vector3 = Vector3(a.x.mul(b), a.y.mul(b), a.z.mul(b));
    Div(a:Vector3, b:Num):Vector3 = a.Mul(1.div(b));
    
    #vector operations
    Add(a:Vector3, b:Vector3):Vector3 = Vector3(a.x.add(b.x), a.y.add(b.y), a.z.add(b.z));
    Sub(a:Vector3, b:Vector3):Vector3 = a.Add(Opposite(b));
    
    Dot(a:Vector3, b:Vector3):Num
    {
        s = Vector3(a.x.mul(b.x), a.y.mul(b.y), a.z.mul(b.z));
        return = s.x.add(s.y).add(s.z);
    }
        
    Distance(a:Vector3, b:Vector3):Num 
    {
       diff = a.Sub(b);
       return = diff.Magnitude;
    }

    Angle(a:Vector3, b:Vector3):Num 
    {
        dot = a.Dot(b);
        mag = a.Magnitude.mul(b.Magnitude);
        theta = Num.acos(dot.div(mag));
        return = Num.degrees(theta);  
    }
    
    Reflect(l:Vector3, n:Vector3):Vector3
    {
        dot = n.Dot(l);
        s = 2.mul(dot);
        t = n.Mul(s);
        return = t.Sub(l);
    }
}

#struct Vector3(x:Num, y:Num, z:Num)
#{
#    Up = Vec3(0, 0, 1);
#    Down = Vec3(0, 0, -1);
#    Right = Vec3(1, 0, 0);
#    Left = Vec3(-1, 0, 0);
#    Forward = Vec3(0, 1, 0);
#    Back = Vec3(0, -1, 0);
#
#    Dot(a:Vector3, b:Vector3):Num
#    {
#        s = Vector.mul(a, b);
#        return = add(add(s.x, s.y), s.z);
#    }
#
#    Cross(a:Vector3, b:Vector3) =
#        Vector3(
#            sub(mul(a.y, b.z), mul(a.z, b.y)),
#            sub(mul(a.z, b.x), mul(a.x, b.z)),
#            sub(mul(a.x, b.y), mul(a.y, b.x))
#        );
#
#    Magnitude(v) = sqrt(Dot(v, v));
#
#    Normalize(v)
#    {
#        mapper(x) = div(x, Magnitude(v));
#        return = map(mapper, v);
#    }
#
#    Distance(a, b) = Magnitude(Vector.sub(b, a));
#
#    TransformPosition(vec:Vector3, matrix:Matrix4x4):Vector3
#    {
#        result = V4.Transform(Vector4(vec.x, vec.y, vec.z, 1), matrix);
#        return = Vector3(result.x, result.y, result.z);
#    }
#
#    TransformDirection(vec:Vec3, matrix:Matrix4x4):Vector3
#    {
#        result = V4.Transform(Vector4(vec.x, vec.y, vec.z, 0), matrix);
#        return = Vec3(result.x, result.y, result.z);
#    }
#}
#
#struct Vector4(x:Num, y:Num, z:Num, w:Num)
#{
#    Dot(a:Vector4, b:Vector4):Num
#    {
#        s = Vector.mul(a, b);
#        return = add(add(s.x, s.y), add(s.z, s.w));
#    }
#
#    Transform(vector:Vector4, matrix:Matrix4x4):Vector4
#    {
#        multiply(m):Num = Dot(vector, m);
#        return = map(multiply, Matrix.Transpose(matrix));
#    }
#}