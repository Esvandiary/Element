/* A literal number including sign and decimal point, also including e notation */
literal         ::= [-+]? [0-9]+ ('.' [0-9]*)? ([eE] [-+]? [0-9]+)?
/* Any string including most UTF8 characters but not exactly '_' */
identifier      ::= [_a-zA-Z#x00F0-#xFFFF] [_a-zA-Z0-9#x00F0-#xFFFF]*

/* Literals can be indexed to call instance functions
   Expression list is optional so that constants/nullary functions don't require redundant parentheses */
expression      ::= ((identifier | literal) (indexExpression | callExpression)*) | lambda
indexExpression ::= '.' identifier
callExpression  ::= '(' expression (',' expression)* ')'

qualifier       ::= 'intrinsic'?
type            ::= ':' identifier indexExpression*
port            ::= (identifier type?) | '_'
portList        ::= '(' port (',' port)* ')'

/* Portlist is optional in 2 situations:
       Constant nullary functions where parentheses are redundant
       Declaring interface of intrinsic variadic constructs is impossible (no syntax support for variadics) */
declaration     ::= identifier portList? type?
scope           ::= '{' item* '}'

expressionBody  ::= '=' expression ';'
functionBody    ::= expressionBody | scope
lambda          ::= '_' portList functionBody
function        ::= qualifier declaration (functionBody | ';')
struct          ::= qualifier 'struct' declaration (scope | ';')
constraint      ::= qualifier 'constraint' declaration ';'
namespace       ::= 'namespace' identifier scope

item            ::= function | struct | namespace | constraint
grammar         ::= item*