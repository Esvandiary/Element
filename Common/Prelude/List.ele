# list(...):List;
# Creates a literal List from the parameters
# Elements must be homogeneous
intrinsic list:List;

# Represents a finite set of elements
intrinsic struct List(at:Indexer, count:Num)
{
    # fold summarizes a list
    # Invokes accumulator(total, element) with each element of the list, starting with initial as the total and returning a new total each iteration.
    # For example, fold(array(1, 2, 3), 0, add) evaluates to 0.add(1).add(2).add(3).
    intrinsic fold(list:List, initial, accumulator:Binary);

    map(a:List, mapper:Unary):List = List(_(idx:Num) = mapper(a.at(idx)), a.count);

    zip(a:List, b:List, zipper:Binary):List = List(_(idx:Num) = zipper(a.at(idx), b.at(idx)), Num.min(a.count, b.count));

    repeat(value, count:Num):List = List(_(_:Num) = value, count);

    range(start:Num, count:Num):List 
    {
        indexer(idx:Num)   
        {
            clamped_idx = Bool.if(idx.lt(0), 0, idx.clamp(0, count.sub(1)));
            return = clamped_idx.add(start);
        }

        return = List(indexer, count);
    }

    concatenate(a:List, b:List):List
    {
        indexer(idx:Num) = Bool.if(idx.lt(a.count), a.at(idx), b.at(idx.sub(a.count)));
        count = a.count.add(b.count);
        return = List(indexer, count);
    }

    take(a:List, amount:Num):List
    {
        take = Bool.if(amount.lt(1), 1, a.count.min(amount));

        indexer(idx:Num)   
        {
            clamped_idx = Bool.if(idx.lt(0), 0, idx.clamp(0, amount.min(take.sub(1))));
            return = a.at(clamped_idx);
        }

        return = List(indexer, take);
    }

    skip(a:List, amount:Num):List
    {
        skip = Bool.if(amount.lt(0), 0, a.count.sub(1).min(amount));
        count = a.count.sub(skip);
        
        indexer(idx:Num)
        {
            clamped_idx = idx.clamp(0, count);
            return = a.at(clamped_idx.add(skip));
        }

        return = List(indexer, count);
    }

    slice(a:List, start:Num, count:Num):List
    {
        clamped_start = Bool.if(start.lt(0), 0, start.clamp(0, a.count.sub(1).min(start)));
        clamped_count = Bool.if(count.lt(1), 1, count.clamp(0, a.count.sub(clamped_start).min(count)));

        indexer(idx:Num)
        {
            clamped_idx = Bool.if(idx.lt(0), clamped_start, clamped_start.add(idx.min(clamped_count.sub(1))));
            return = a.at(clamped_idx);
        }

        return = List(indexer, clamped_count);
    }

    filter(a:List, predicate:Predicate):List
    {
        count = countWhere(a, predicate);
        index(idx:Num) = idx.add(a.slice(0, idx).countWhere(_(item) = predicate(item).negate));
        return = List(index, count);
    }

    cycle(a:List):Stream = Stream(_(idx:Num) = a.at(idx.mod(a.count)));

    countWhere(a:List, predicate:Predicate):Num = a.fold(0, _(current, next) = if(predicate(next), add(current, 1), current));

    reverse(a:List):List 
    {
        index(idx:Num) 
        {
            clamped_idx = Num.clamp(a.count.sub(idx).sub(1), 0, a.count);
            return = a.at(clamped_idx);
        }
        
        return = List(index, a.count);
    }

    findLast(a:List, predicate:Predicate, default) = a.fold(default, _(current, next) = predicate(next).if(next, current));

    findFirst(a:List, predicate:Predicate, default) = a.reverse.findLast(predicate, default);
}